// Type definitions for commander
// Original definitions by: Alan Agius <https://github.com/alan-agius4>, Marcelo Dezem <https://github.com/mdezem>, vvakame <https://github.com/vvakame>, Jules Randolph <https://github.com/sveinburne>

// Using method rather than property for method-signature-style, to document method overloads separately. Allow either.
/* eslint-disable @typescript-eslint/method-signature-style */
/* eslint-disable @typescript-eslint/no-explicit-any */

declare namespace commander {

  interface CommanderError extends Error {
    code: string;
    exitCode: number;
    message: string;
    nestedError?: string;
  }
  type CommanderErrorConstructor = new (exitCode: number, code: string, message: string) => CommanderError;

  // eslint-disable-next-line @typescript-eslint/no-empty-interface
  interface InvalidOptionArgumentError extends CommanderError {
  }
  type InvalidOptionArgumentErrorConstructor = new (message: string) => InvalidOptionArgumentError;

  interface Option {
    flags: string;
    description: string;

    required: boolean; // A value must be supplied when the option is specified.
    optional: boolean; // A value is optional when the option is specified.
    variadic: boolean;
    mandatory: boolean; // The option must have a value after parsing, which usually means it must be specified on command line.
    optionFlags: string;
    short?: string;
    long?: string;
    negate: boolean;
    defaultValue?: any;
    defaultValueDescription?: string;
    parseArg?: <T>(value: string, previous: T) => T;
    hidden: boolean;
    argChoices?: string[];

    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     */
    default(value: any, description?: string): this;

    /**
     * Calculate the full description, including defaultValue etc.
     */
    fullDescription(): string;

    /**
     * Set the custom handler for processing CLI option arguments into option values.
     */
    argParser<T>(fn: (value: string, previous: T) => T): this;

    /**
     * Whether the option is mandatory and must have a value after parsing.
     */
    makeOptionMandatory(mandatory?: boolean): this;

    /**
     * Hide option in help.
     */
    hideHelp(hide?: boolean): this;

    /**
     * Validation of option argument failed.
     * Intended for use from custom argument processing functions.
     */
    argumentRejected(messsage: string): never;

    /**
     * Only allow option value to be one of choices.
     */
    choices(values: string[]): this;

    /**
     * Return option name.
     */
    name(): string;

    /**
     * Return option name, in a camelcase format that can be used
     * as a object attribute key.
     */
    attributeName(): string;
  }
  type OptionConstructor = new (flags: string, description?: string) => Option;

  interface Help {
    /** output helpWidth, long lines are wrapped to fit */
    helpWidth?: number;
    sortSubcommands: boolean;
    sortOptions: boolean;

    /** Get the command term to show in the list of subcommands. */
    subcommandTerm(cmd: Command): string;
    /** Get the command description to show in the list of subcommands. */
    subcommandDescription(cmd: Command): string;
    /** Get the option term to show in the list of options. */
    optionTerm(option: Option): string;
    /** Get the option description to show in the list of options. */
    optionDescription(option: Option): string;

    /** Get the command usage to be displayed at the top of the built-in help. */
    commandUsage(cmd: Command): string;
    /** Get the description for the command. */
    commandDescription(cmd: Command): string;

    /** Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one. */
    visibleCommands(cmd: Command): Command[];
    /** Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one. */
    visibleOptions(cmd: Command): Option[];
    /** Get an array of the arguments which have descriptions. */
    visibleArguments(cmd: Command): Array<{ term: string; description: string}>;

    /** Get the longest command term length. */
    longestSubcommandTermLength(cmd: Command, helper: Help): number;
    /** Get the longest option term length. */
    longestOptionTermLength(cmd: Command, helper: Help): number;
    /** Get the longest argument term length. */
    longestArgumentTermLength(cmd: Command, helper: Help): number;
    /** Calculate the pad width from the maximum term length. */
    padWidth(cmd: Command, helper: Help): number;

    /**
     * Wrap the given string to width characters per line, with lines after the first indented.
     * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
     */
    wrap(str: string, width: number, indent: number, minColumnWidth?: number): string;

    /** Generate the built-in help text. */
    formatHelp(cmd: Command, helper: Help): string;
  }
  type HelpConstructor = new () => Help;
  type HelpConfiguration = Partial<Help>;

  interface ParseOptions {
    from: 'node' | 'electron' | 'user';
  }
  interface HelpContext {